# v2/core/app_integrator.py

"""
FluidKit V2 App Integration

Main integration API for FluidKit with FastAPI applications with multi-language support.
Orchestrates route collection, model discovery, and optional code generation.
"""

import logging
from enum import Enum
from pathlib import Path
from fastapi import FastAPI
from typing import List, Dict, Tuple
from fastapi.routing import APIRoute

from introspection.routes import route_to_node
from introspection.models import discover_models_from_routes
from core.schema import FluidKitApp, RouteNode, LanguageType


logger = logging.getLogger(__name__)


def integrate(
    app: FastAPI, 
    lang: str = "typescript",
    strategy: str = "mirror",
    verbose: bool = False,
    **options
) -> Tuple[FluidKitApp, Dict[str, str]]:
    """
    Integrate FluidKit with FastAPI app using runtime introspection.
    
    Args:
        app: FastAPI application instance
        lang: Target language for code generation ("ts"/"typescript" default)
        strategy: Generation strategy ("co-locate" or "mirror")
        verbose: Enable detailed logging
        **options: Additional options (project_root, runtime config, etc.)
        
    Returns:
        (FluidKitApp, generated_files_dict)
    """
    # Configure logging
    if verbose:
        logging.basicConfig(level=logging.DEBUG, format='%(levelname)s: %(message)s')
    
    # Step 1: Introspection
    project_root = options.get('project_root') or str(Path.cwd().resolve())
    
    if verbose:
        logger.info("Starting FluidKit integration with FastAPI app")
        logger.debug(f"Project root: {project_root}")
    
    # Collect and convert routes
    api_routes = _collect_fastapi_routes(app)
    route_nodes = _convert_routes_to_nodes(api_routes)
    
    # Discover models
    model_nodes = discover_models_from_routes(route_nodes, project_root)
    
    # Build FluidKitApp
    fluid_app = FluidKitApp(
        models=model_nodes,
        routes=route_nodes,
        app_instance=app,
        metadata={'project_root': project_root, **options}
    )
    
    if verbose:
        logger.info(f"Introspection complete: {len(route_nodes)} routes, {len(model_nodes)} models")
    
    # Step 2: Code Generation
    normalized_lang = _normalize_language(lang)
    
    if normalized_lang == LanguageType.TYPESCRIPT:
        generated_files = _generate_and_write_typescript(fluid_app, strategy, verbose, **options)
        
        if not verbose:
            print(f"FluidKit: Generated {len(generated_files)} TypeScript files ({strategy} strategy)")
        
        return fluid_app, generated_files
    
    else:
        # Future language support
        raise NotImplementedError(f"Language '{lang}' not yet supported. Currently supported: ts, typescript")
    

def _generate_and_write_typescript(
    fluid_app: FluidKitApp, 
    strategy: str, 
    verbose: bool,
    **options
) -> Dict[str, str]:
    """Generate TypeScript files and write them to disk."""
    from generators.typescript.pipeline import generate_typescript_files
    
    # Generate file contents
    generated_files = generate_typescript_files(
        fluid_app=fluid_app,
        strategy=strategy,
        **options
    )
    
    # Write files to disk
    _write_generated_files(generated_files, verbose)
    
    return generated_files


def _write_generated_files(generated_files: Dict[str, str], verbose: bool):
    """Write generated files to disk with auto-generated headers."""
    for file_path, content in generated_files.items():
        try:
            # Create directory if it doesn't exist (OS-independent)
            file_path_obj = Path(file_path)
            file_path_obj.parent.mkdir(parents=True, exist_ok=True)
            
            # Add auto-generated header
            header = _get_file_header(file_path_obj.suffix)
            final_content = header + content
            
            # Write file content (OS-independent)
            with open(file_path_obj, 'w', encoding='utf-8') as f:
                f.write(final_content)
            
            if verbose:
                logger.debug(f"Generated: {file_path}")
            
        except Exception as e:
            error_msg = f"Failed to write {file_path}: {e}"
            if verbose:
                logger.error(error_msg)
            else:
                print(f"❌ {error_msg}")


def _get_file_header(file_extension: str) -> str:
    """Get auto-generated file header based on file type."""
    if file_extension == '.ts':
        return '''/**
 * Auto-generated by FluidKit - DO NOT EDIT
 * This file is automatically generated from your FastAPI routes and models.
 * Changes to this file will be overwritten on the next generation.
 */

'''
    elif file_extension == '.py':
        return '''"""
Auto-generated by FluidKit - DO NOT EDIT
This file is automatically generated from your FastAPI routes and models.
Changes to this file will be overwritten on the next generation.
"""

'''
    elif file_extension == '.js':
        return '''/**
 * Auto-generated by FluidKit - DO NOT EDIT
 * This file is automatically generated from your FastAPI routes and models.
 * Changes to this file will be overwritten on the next generation.
 */

'''
    else:
        return '''/*
 * Auto-generated by FluidKit - DO NOT EDIT
 * This file is automatically generated from your FastAPI routes and models.
 * Changes to this file will be overwritten on the next generation.
 */

'''


def _normalize_language(lang: str) -> LanguageType:
    """Normalize language string to LanguageType enum."""
    lang_lower = lang.lower()
    
    if lang_lower in ["ts", "typescript"]:
        return LanguageType.TYPESCRIPT
    
    # Future support
    # elif lang_lower in ["py", "python"]:
    #     return LanguageType.PYTHON
    # elif lang_lower in ["js", "javascript"]:
    #     return LanguageType.JAVASCRIPT
    
    else:
        valid_langs = ["ts", "typescript"]
        raise ValueError(f"Unsupported language '{lang}'. Supported: {', '.join(valid_langs)}")
    

def _collect_fastapi_routes(app: FastAPI) -> List[APIRoute]:
    """Collect user-defined API routes from FastAPI app."""
    user_routes = []
    
    for route in app.routes:
        if isinstance(route, APIRoute) and _is_user_defined_route(route):
            user_routes.append(route)
    
    return user_routes


def _convert_routes_to_nodes(api_routes: List[APIRoute]) -> List[RouteNode]:
    """Convert FastAPI APIRoute objects to RouteNode objects."""
    route_nodes = []
    
    for route in api_routes:
        try:
            route_node = route_to_node(route)
            if route_node:
                route_nodes.append(route_node)
        except Exception as e:
            logger.warning(f"Failed to convert route {route.path}: {e}")
            continue
    
    return route_nodes


def _is_user_defined_route(route: APIRoute) -> bool:
    """Determine if route is user-defined using module-based filtering."""
    endpoint = route.endpoint
    
    # Basic validation
    if (not endpoint or not callable(endpoint) or 
        not hasattr(endpoint, '__name__') or endpoint.__name__ == '<lambda>' or
        not hasattr(endpoint, '__module__') or not route.methods):
        return False
    
    # Filter out system modules
    endpoint_module = endpoint.__module__
    system_prefixes = ('fastapi.', 'starlette.')
    
    if any(endpoint_module.startswith(prefix) for prefix in system_prefixes):
        return False
    
    # Check for valid HTTP methods
    valid_methods = {'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE'}
    if not any(method in valid_methods for method in route.methods):
        return False
    
    # Check for ASGI apps (mounted static files, etc.)
    if hasattr(endpoint, 'app') and hasattr(endpoint, '__call__'):
        return False
    
    return True


# === CONVENIENCE FUNCTIONS === #

def introspect_only(app: FastAPI, **options) -> FluidKitApp:
    """
    Convenience function for introspection only (no code generation).
    """
    # Temporarily generate files to get FluidKitApp, but don't write them
    from generators.typescript.pipeline import generate_typescript_files
    
    project_root = options.get('project_root') or str(Path.cwd().resolve())
    
    # Collect and convert routes
    api_routes = _collect_fastapi_routes(app)
    route_nodes = _convert_routes_to_nodes(api_routes)
    
    # Discover models
    model_nodes = discover_models_from_routes(route_nodes, project_root)
    
    # Build FluidKitApp
    fluid_app = FluidKitApp(
        models=model_nodes,
        routes=route_nodes,
        app_instance=app,
        metadata={'project_root': project_root, **options}
    )
    
    print(f"FluidKit: Introspected {len(route_nodes)} routes, {len(model_nodes)} models")
    return fluid_app


def generate_only(app: FastAPI, strategy: str = "mirror", **options) -> Dict[str, str]:
    """
    Convenience function to generate files without writing to disk.
    
    Returns:
        Dict mapping file_path -> file_content (files not written to disk)
    """
    from generators.typescript.pipeline import generate_typescript_files
    
    project_root = options.get('project_root') or str(Path.cwd().resolve())
    
    # Collect and convert routes
    api_routes = _collect_fastapi_routes(app)
    route_nodes = _convert_routes_to_nodes(api_routes)
    
    # Discover models
    model_nodes = discover_models_from_routes(route_nodes, project_root)
    
    # Build FluidKitApp
    fluid_app = FluidKitApp(
        models=model_nodes,
        routes=route_nodes,
        app_instance=app,
        metadata={'project_root': project_root, **options}
    )
    
    # Generate files (but don't write them)
    generated_files = generate_typescript_files(
        fluid_app=fluid_app,
        strategy=strategy,
        **options
    )
    
    print(f"FluidKit: Generated {len(generated_files)} TypeScript files ({strategy} strategy) - not written to disk")
    return generated_files


# === TESTING FUNCTION === #

def test_integration():
    """Test the integration with file writing."""
    try:
        from tests.app import app
        
        print("=== FLUIDKIT V2 INTEGRATION TEST ===")
        
        # Test 1: Default integration (generates and writes files)
        print("\n1. Default integration (mirror strategy):")
        fluid_app, files = integrate(app)
        
        # Test 2: Co-locate strategy
        print("\n2. Co-locate strategy:")
        fluid_app, files = integrate(app, strategy="co-locate")
        
        # Test 3: Introspection only
        print("\n3. Introspection only:")
        fluid_app = introspect_only(app)
        
        # Test 4: Generate only (don't write)
        print("\n4. Generate only (no file writing):")
        files = generate_only(app)
        
        print("\n✅ All tests passed!")
        
    except ImportError:
        print("❌ Could not import v2.examples.test - ensure example files exist")
    except Exception as e:
        print(f"❌ Test failed: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    test_integration()
