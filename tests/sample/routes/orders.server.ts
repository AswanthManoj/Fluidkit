/**
 * Auto-generated by FluidKit from FastAPI routes and models - DO NOT EDIT
 * Changes will be overwritten on regeneration.
 */

import type { ApiResult, FluidTypes, SSECallbacks, SSEConnection, SSERequestInit, StreamingCallbacks } from '../.fluidkit/runtime';
import { getBaseUrl, handleResponse } from '../.fluidkit/runtime';
import type { CreateOrderRequest, OrderListResponse, OrderResponse, OrderStatus, ShippingMethod } from '../models/orders';

/**
 * List orders with filtering
 *
 * @param page
 * @param per_page
 * @param status
 * @param customer_id
 */
export const list_orders = async (page?: number, per_page?: number, status?: OrderStatus, customer_id?: FluidTypes.UUID, options?: RequestInit): Promise<ApiResult<OrderListResponse>> => {
  let url = `${getBaseUrl()}/orders/orders/`;

  const searchParams = new URLSearchParams();
  if (page !== undefined) {
    searchParams.set('page', String(page));
  }
  if (per_page !== undefined) {
    searchParams.set('per_page', String(per_page));
  }
  if (status !== undefined) {
    searchParams.set('status', String(status));
  }
  if (customer_id !== undefined) {
    searchParams.set('customer_id', String(customer_id));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Create a new order
 *
 * @param order_data
 * @param auto_confirm
 * @param send_confirmation_email
 */
export const create_order = async (order_data: CreateOrderRequest, auto_confirm?: boolean, send_confirmation_email?: boolean, options?: RequestInit): Promise<ApiResult<OrderResponse>> => {
  let url = `${getBaseUrl()}/orders/orders/`;

  const searchParams = new URLSearchParams();
  if (auto_confirm !== undefined) {
    searchParams.set('auto_confirm', String(auto_confirm));
  }
  if (send_confirmation_email !== undefined) {
    searchParams.set('send_confirmation_email', String(send_confirmation_email));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers
    },
    body: JSON.stringify(order_data),
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Update order
 *
 * @param order_id
 * @param status
 * @param shipping_method
 * @param notify_customer
 */
export const update_order = async (order_id: FluidTypes.UUID, status?: OrderStatus, shipping_method?: ShippingMethod, notify_customer?: boolean, options?: RequestInit): Promise<ApiResult<OrderResponse>> => {
  let url = `${getBaseUrl()}/orders/orders/${order_id}`;

  const searchParams = new URLSearchParams();
  if (status !== undefined) {
    searchParams.set('status', String(status));
  }
  if (shipping_method !== undefined) {
    searchParams.set('shipping_method', String(shipping_method));
  }
  if (notify_customer !== undefined) {
    searchParams.set('notify_customer', String(notify_customer));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'PUT',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Cancel order with refund
 *
 * @param order_id
 * @param reason
 * @param refund_amount
 * @param notify_customer
 */
export const cancel_order = async (order_id: FluidTypes.UUID, reason: string, refund_amount?: number, notify_customer?: boolean, options?: RequestInit): Promise<ApiResult<OrderResponse>> => {
  let url = `${getBaseUrl()}/orders/orders/${order_id}/cancel`;

  const searchParams = new URLSearchParams();
  searchParams.set('reason', String(reason));
  if (refund_amount !== undefined) {
    searchParams.set('refund_amount', String(refund_amount));
  }
  if (notify_customer !== undefined) {
    searchParams.set('notify_customer', String(notify_customer));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'POST',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Stream real-time order status updates (Server-Sent Events)
 *
 * @param order_id
 * @param callbacks - SSE event handlers
 * @param options - EventSource options
 *
 * **Stream Type:** text/event-stream
 */
export const stream_order_updates = (order_id: FluidTypes.UUID, callbacks: SSECallbacks, options?: SSERequestInit): SSEConnection => {
  let url = `${getBaseUrl()}/orders/orders/${order_id}/updates`;

  const eventSource = new EventSource(url, {
    withCredentials: options?.withCredentials,
    ...options
  });

  if (callbacks.onOpen) {
    eventSource.addEventListener('open', callbacks.onOpen);
  }

  if (callbacks.onMessage) {
    eventSource.addEventListener('message', callbacks.onMessage);
  }

  if (callbacks.onError) {
    eventSource.addEventListener('error', callbacks.onError);
  }

  if (callbacks.onClose) {
    eventSource.addEventListener('close', callbacks.onClose);
  }

  return {
    close: () => eventSource.close(),
    readyState: eventSource.readyState,
    url: eventSource.url,
    addEventListener: eventSource.addEventListener.bind(eventSource),
    removeEventListener: eventSource.removeEventListener.bind(eventSource)
  };
};

/**
 * Stream order analytics reports (JSON/data streaming)
 * @param callbacks - Streaming event handlers
 * @param options - Request options
 *
 * **Stream Type:** application/x-ndjson
 */
export const stream_order_reports = async (callbacks: StreamingCallbacks<any>, options?: RequestInit): Promise<void> => {
  let url = `${getBaseUrl()}/orders/orders/reports/stream`;

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  try {
    const response = await fetch(url, requestOptions);

    if (!response.ok) {
      callbacks.onError?.(new Error(`HTTP ${response.status}: ${response.statusText}`));
      return;
    }

    const reader = response.body?.getReader();
    if (!reader) {
      callbacks.onError?.(new Error('Response body is not readable'));
      return;
    }

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      try {
        const chunk = JSON.parse(new TextDecoder().decode(value));
        callbacks.onChunk?.(chunk);
      }
      catch (parseError) {
        callbacks.onError?.(parseError instanceof Error ? parseError : new Error('JSON parse error'));
        break;
      }
    }

    callbacks.onComplete?.();
  }
  catch (error) {
    callbacks.onError?.(error instanceof Error ? error : new Error('Streaming error'));
  }
};

/**
 * List orders with filtering
 *
 * @param page
 * @param per_page
 * @param status
 * @param customer_id
 */
export const list_orders = async (page?: number, per_page?: number, status?: OrderStatus, customer_id?: FluidTypes.UUID, options?: RequestInit): Promise<ApiResult<OrderListResponse>> => {
  let url = `${getBaseUrl()}/orders/orders/`;

  const searchParams = new URLSearchParams();
  if (page !== undefined) {
    searchParams.set('page', String(page));
  }
  if (per_page !== undefined) {
    searchParams.set('per_page', String(per_page));
  }
  if (status !== undefined) {
    searchParams.set('status', String(status));
  }
  if (customer_id !== undefined) {
    searchParams.set('customer_id', String(customer_id));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Create a new order
 *
 * @param order_data
 * @param auto_confirm
 * @param send_confirmation_email
 */
export const create_order = async (order_data: CreateOrderRequest, auto_confirm?: boolean, send_confirmation_email?: boolean, options?: RequestInit): Promise<ApiResult<OrderResponse>> => {
  let url = `${getBaseUrl()}/orders/orders/`;

  const searchParams = new URLSearchParams();
  if (auto_confirm !== undefined) {
    searchParams.set('auto_confirm', String(auto_confirm));
  }
  if (send_confirmation_email !== undefined) {
    searchParams.set('send_confirmation_email', String(send_confirmation_email));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers
    },
    body: JSON.stringify(order_data),
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Update order
 *
 * @param order_id
 * @param status
 * @param shipping_method
 * @param notify_customer
 */
export const update_order = async (order_id: FluidTypes.UUID, status?: OrderStatus, shipping_method?: ShippingMethod, notify_customer?: boolean, options?: RequestInit): Promise<ApiResult<OrderResponse>> => {
  let url = `${getBaseUrl()}/orders/orders/${order_id}`;

  const searchParams = new URLSearchParams();
  if (status !== undefined) {
    searchParams.set('status', String(status));
  }
  if (shipping_method !== undefined) {
    searchParams.set('shipping_method', String(shipping_method));
  }
  if (notify_customer !== undefined) {
    searchParams.set('notify_customer', String(notify_customer));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'PUT',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Cancel order with refund
 *
 * @param order_id
 * @param reason
 * @param refund_amount
 * @param notify_customer
 */
export const cancel_order = async (order_id: FluidTypes.UUID, reason: string, refund_amount?: number, notify_customer?: boolean, options?: RequestInit): Promise<ApiResult<OrderResponse>> => {
  let url = `${getBaseUrl()}/orders/orders/${order_id}/cancel`;

  const searchParams = new URLSearchParams();
  searchParams.set('reason', String(reason));
  if (refund_amount !== undefined) {
    searchParams.set('refund_amount', String(refund_amount));
  }
  if (notify_customer !== undefined) {
    searchParams.set('notify_customer', String(notify_customer));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'POST',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Stream real-time order status updates (Server-Sent Events)
 *
 * @param order_id
 * @param callbacks - SSE event handlers
 * @param options - EventSource options
 *
 * **Stream Type:** text/event-stream
 */
export const stream_order_updates = (order_id: FluidTypes.UUID, callbacks: SSECallbacks, options?: SSERequestInit): SSEConnection => {
  let url = `${getBaseUrl()}/orders/orders/${order_id}/updates`;

  const eventSource = new EventSource(url, {
    withCredentials: options?.withCredentials,
    ...options
  });

  if (callbacks.onOpen) {
    eventSource.addEventListener('open', callbacks.onOpen);
  }

  if (callbacks.onMessage) {
    eventSource.addEventListener('message', callbacks.onMessage);
  }

  if (callbacks.onError) {
    eventSource.addEventListener('error', callbacks.onError);
  }

  if (callbacks.onClose) {
    eventSource.addEventListener('close', callbacks.onClose);
  }

  return {
    close: () => eventSource.close(),
    readyState: eventSource.readyState,
    url: eventSource.url,
    addEventListener: eventSource.addEventListener.bind(eventSource),
    removeEventListener: eventSource.removeEventListener.bind(eventSource)
  };
};

/**
 * Stream order analytics reports (JSON/data streaming)
 * @param callbacks - Streaming event handlers
 * @param options - Request options
 *
 * **Stream Type:** application/x-ndjson
 */
export const stream_order_reports = async (callbacks: StreamingCallbacks<any>, options?: RequestInit): Promise<void> => {
  let url = `${getBaseUrl()}/orders/orders/reports/stream`;

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  try {
    const response = await fetch(url, requestOptions);

    if (!response.ok) {
      callbacks.onError?.(new Error(`HTTP ${response.status}: ${response.statusText}`));
      return;
    }

    const reader = response.body?.getReader();
    if (!reader) {
      callbacks.onError?.(new Error('Response body is not readable'));
      return;
    }

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      try {
        const chunk = JSON.parse(new TextDecoder().decode(value));
        callbacks.onChunk?.(chunk);
      }
      catch (parseError) {
        callbacks.onError?.(parseError instanceof Error ? parseError : new Error('JSON parse error'));
        break;
      }
    }

    callbacks.onComplete?.();
  }
  catch (error) {
    callbacks.onError?.(error instanceof Error ? error : new Error('Streaming error'));
  }
};