/**
 * Auto-generated by FluidKit from FastAPI routes and models - DO NOT EDIT
 * Changes will be overwritten on regeneration.
 */

import type { ApiResult, FluidTypes, SSECallbacks, SSEConnection, SSERequestInit, StreamingCallbacks, TextStreamCallbacks } from '../.fluidkit/runtime';
import { getBaseUrl, handleResponse } from '../.fluidkit/runtime';
import type { CreateUserRequest, UserListResponse, UserResponse, UserRole, UserStatus } from '../models/users';

/**
 * List users with filtering and pagination
 *
 * @param page
 * @param per_page
 * @param role
 * @param status
 * @param search
 */
export const list_users = async (page?: number, per_page?: number, role?: UserRole, status?: UserStatus, search?: string, options?: RequestInit): Promise<ApiResult<UserListResponse>> => {
  let url = `${getBaseUrl()}/users/users/`;

  const searchParams = new URLSearchParams();
  if (page !== undefined) {
    searchParams.set('page', String(page));
  }
  if (per_page !== undefined) {
    searchParams.set('per_page', String(per_page));
  }
  if (role !== undefined) {
    searchParams.set('role', String(role));
  }
  if (status !== undefined) {
    searchParams.set('status', String(status));
  }
  if (search !== undefined) {
    searchParams.set('search', String(search));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Get user by ID
 *
 * @param user_id
 * @param include_balance
 */
export const get_user = async (user_id: FluidTypes.UUID, include_balance?: boolean, options?: RequestInit): Promise<ApiResult<UserResponse>> => {
  let url = `${getBaseUrl()}/users/users/${user_id}`;

  const searchParams = new URLSearchParams();
  if (include_balance !== undefined) {
    searchParams.set('include_balance', String(include_balance));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Create a new user
 *
 * @param user_data
 * @param send_welcome_email
 */
export const create_user = async (user_data: CreateUserRequest, send_welcome_email?: boolean, options?: RequestInit): Promise<ApiResult<UserResponse>> => {
  let url = `${getBaseUrl()}/users/users/`;

  const searchParams = new URLSearchParams();
  if (send_welcome_email !== undefined) {
    searchParams.set('send_welcome_email', String(send_welcome_email));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers
    },
    body: JSON.stringify(user_data),
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Update user information
 *
 * @param user_id
 * @param username
 * @param email
 * @param role
 * @param send_notification
 */
export const update_user = async (user_id: FluidTypes.UUID, username?: string, email?: string, role?: UserRole, send_notification?: boolean, options?: RequestInit): Promise<ApiResult<UserResponse>> => {
  let url = `${getBaseUrl()}/users/users/${user_id}`;

  const searchParams = new URLSearchParams();
  if (username !== undefined) {
    searchParams.set('username', String(username));
  }
  if (email !== undefined) {
    searchParams.set('email', String(email));
  }
  if (role !== undefined) {
    searchParams.set('role', String(role));
  }
  if (send_notification !== undefined) {
    searchParams.set('send_notification', String(send_notification));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'PUT',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Delete user
 *
 * @param user_id
 * @param hard_delete
 */
export const delete_user = async (user_id: FluidTypes.UUID, hard_delete?: boolean, options?: RequestInit): Promise<ApiResult<null>> => {
  let url = `${getBaseUrl()}/users/users/${user_id}`;

  const searchParams = new URLSearchParams();
  if (hard_delete !== undefined) {
    searchParams.set('hard_delete', String(hard_delete));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'DELETE',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Stream real-time user activity events (Server-Sent Events)
 *
 * @param user_id
 * @param callbacks - SSE event handlers
 * @param options - EventSource options
 *
 * **Stream Type:** text/event-stream
 */
export const stream_user_events = (user_id: FluidTypes.UUID, callbacks: SSECallbacks, options?: SSERequestInit): SSEConnection => {
  let url = `${getBaseUrl()}/users/users/${user_id}/events`;

  const eventSource = new EventSource(url, {
    withCredentials: options?.withCredentials,
    ...options
  });

  if (callbacks.onOpen) {
    eventSource.addEventListener('open', callbacks.onOpen);
  }

  if (callbacks.onMessage) {
    eventSource.addEventListener('message', callbacks.onMessage);
  }

  if (callbacks.onError) {
    eventSource.addEventListener('error', callbacks.onError);
  }

  if (callbacks.onClose) {
    eventSource.addEventListener('close', callbacks.onClose);
  }

  return {
    close: () => eventSource.close(),
    readyState: eventSource.readyState,
    url: eventSource.url,
    addEventListener: eventSource.addEventListener.bind(eventSource),
    removeEventListener: eventSource.removeEventListener.bind(eventSource)
  };
};

/**
 * Stream user analytics data (JSON/data streaming)
 * @param callbacks - Streaming event handlers
 * @param options - Request options
 *
 * **Stream Type:** application/x-ndjson
 */
export const stream_user_analytics = async (callbacks: StreamingCallbacks<any>, options?: RequestInit): Promise<void> => {
  let url = `${getBaseUrl()}/users/users/analytics/stream`;

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  try {
    const response = await fetch(url, requestOptions);

    if (!response.ok) {
      callbacks.onError?.(new Error(`HTTP ${response.status}: ${response.statusText}`));
      return;
    }

    const reader = response.body?.getReader();
    if (!reader) {
      callbacks.onError?.(new Error('Response body is not readable'));
      return;
    }

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      try {
        const chunk = JSON.parse(new TextDecoder().decode(value));
        callbacks.onChunk?.(chunk);
      }
      catch (parseError) {
        callbacks.onError?.(parseError instanceof Error ? parseError : new Error('JSON parse error'));
        break;
      }
    }

    callbacks.onComplete?.();
  }
  catch (error) {
    callbacks.onError?.(error instanceof Error ? error : new Error('Streaming error'));
  }
};

/**
 * Export users as CSV file (Text streaming)
 * @param callbacks - Streaming event handlers
 * @param options - Request options
 *
 * **Stream Type:** text/csv
 */
export const export_users_csv = async (callbacks: TextStreamCallbacks, options?: RequestInit): Promise<void> => {
  let url = `${getBaseUrl()}/users/users/export/csv`;

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  try {
    const response = await fetch(url, requestOptions);

    if (!response.ok) {
      callbacks.onError?.(new Error(`HTTP ${response.status}: ${response.statusText}`));
      return;
    }

    const reader = response.body?.getReader();
    const decoder = new TextDecoder();

    if (!reader) {
      callbacks.onError?.(new Error('Response body is not readable'));
      return;
    }

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const text = decoder.decode(value);
      callbacks.onChunk?.(text);
    }

    callbacks.onComplete?.();
  }
  catch (error) {
    callbacks.onError?.(error instanceof Error ? error : new Error('Text streaming error'));
  }
};

/**
 * List users with filtering and pagination
 *
 * @param page
 * @param per_page
 * @param role
 * @param status
 * @param search
 */
export const list_users = async (page?: number, per_page?: number, role?: UserRole, status?: UserStatus, search?: string, options?: RequestInit): Promise<ApiResult<UserListResponse>> => {
  let url = `${getBaseUrl()}/users/users/`;

  const searchParams = new URLSearchParams();
  if (page !== undefined) {
    searchParams.set('page', String(page));
  }
  if (per_page !== undefined) {
    searchParams.set('per_page', String(per_page));
  }
  if (role !== undefined) {
    searchParams.set('role', String(role));
  }
  if (status !== undefined) {
    searchParams.set('status', String(status));
  }
  if (search !== undefined) {
    searchParams.set('search', String(search));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Get user by ID
 *
 * @param user_id
 * @param include_balance
 */
export const get_user = async (user_id: FluidTypes.UUID, include_balance?: boolean, options?: RequestInit): Promise<ApiResult<UserResponse>> => {
  let url = `${getBaseUrl()}/users/users/${user_id}`;

  const searchParams = new URLSearchParams();
  if (include_balance !== undefined) {
    searchParams.set('include_balance', String(include_balance));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Create a new user
 *
 * @param user_data
 * @param send_welcome_email
 */
export const create_user = async (user_data: CreateUserRequest, send_welcome_email?: boolean, options?: RequestInit): Promise<ApiResult<UserResponse>> => {
  let url = `${getBaseUrl()}/users/users/`;

  const searchParams = new URLSearchParams();
  if (send_welcome_email !== undefined) {
    searchParams.set('send_welcome_email', String(send_welcome_email));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers
    },
    body: JSON.stringify(user_data),
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Update user information
 *
 * @param user_id
 * @param username
 * @param email
 * @param role
 * @param send_notification
 */
export const update_user = async (user_id: FluidTypes.UUID, username?: string, email?: string, role?: UserRole, send_notification?: boolean, options?: RequestInit): Promise<ApiResult<UserResponse>> => {
  let url = `${getBaseUrl()}/users/users/${user_id}`;

  const searchParams = new URLSearchParams();
  if (username !== undefined) {
    searchParams.set('username', String(username));
  }
  if (email !== undefined) {
    searchParams.set('email', String(email));
  }
  if (role !== undefined) {
    searchParams.set('role', String(role));
  }
  if (send_notification !== undefined) {
    searchParams.set('send_notification', String(send_notification));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'PUT',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Delete user
 *
 * @param user_id
 * @param hard_delete
 */
export const delete_user = async (user_id: FluidTypes.UUID, hard_delete?: boolean, options?: RequestInit): Promise<ApiResult<null>> => {
  let url = `${getBaseUrl()}/users/users/${user_id}`;

  const searchParams = new URLSearchParams();
  if (hard_delete !== undefined) {
    searchParams.set('hard_delete', String(hard_delete));
  }
  if (searchParams.toString()) {
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method: 'DELETE',
    headers: options?.headers,
    ...options
  };

  const response = await fetch(url, requestOptions);
  return handleResponse(response);
};

/**
 * Stream real-time user activity events (Server-Sent Events)
 *
 * @param user_id
 * @param callbacks - SSE event handlers
 * @param options - EventSource options
 *
 * **Stream Type:** text/event-stream
 */
export const stream_user_events = (user_id: FluidTypes.UUID, callbacks: SSECallbacks, options?: SSERequestInit): SSEConnection => {
  let url = `${getBaseUrl()}/users/users/${user_id}/events`;

  const eventSource = new EventSource(url, {
    withCredentials: options?.withCredentials,
    ...options
  });

  if (callbacks.onOpen) {
    eventSource.addEventListener('open', callbacks.onOpen);
  }

  if (callbacks.onMessage) {
    eventSource.addEventListener('message', callbacks.onMessage);
  }

  if (callbacks.onError) {
    eventSource.addEventListener('error', callbacks.onError);
  }

  if (callbacks.onClose) {
    eventSource.addEventListener('close', callbacks.onClose);
  }

  return {
    close: () => eventSource.close(),
    readyState: eventSource.readyState,
    url: eventSource.url,
    addEventListener: eventSource.addEventListener.bind(eventSource),
    removeEventListener: eventSource.removeEventListener.bind(eventSource)
  };
};

/**
 * Stream user analytics data (JSON/data streaming)
 * @param callbacks - Streaming event handlers
 * @param options - Request options
 *
 * **Stream Type:** application/x-ndjson
 */
export const stream_user_analytics = async (callbacks: StreamingCallbacks<any>, options?: RequestInit): Promise<void> => {
  let url = `${getBaseUrl()}/users/users/analytics/stream`;

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  try {
    const response = await fetch(url, requestOptions);

    if (!response.ok) {
      callbacks.onError?.(new Error(`HTTP ${response.status}: ${response.statusText}`));
      return;
    }

    const reader = response.body?.getReader();
    if (!reader) {
      callbacks.onError?.(new Error('Response body is not readable'));
      return;
    }

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      try {
        const chunk = JSON.parse(new TextDecoder().decode(value));
        callbacks.onChunk?.(chunk);
      }
      catch (parseError) {
        callbacks.onError?.(parseError instanceof Error ? parseError : new Error('JSON parse error'));
        break;
      }
    }

    callbacks.onComplete?.();
  }
  catch (error) {
    callbacks.onError?.(error instanceof Error ? error : new Error('Streaming error'));
  }
};

/**
 * Export users as CSV file (Text streaming)
 * @param callbacks - Streaming event handlers
 * @param options - Request options
 *
 * **Stream Type:** text/csv
 */
export const export_users_csv = async (callbacks: TextStreamCallbacks, options?: RequestInit): Promise<void> => {
  let url = `${getBaseUrl()}/users/users/export/csv`;

  const requestOptions: RequestInit = {
    method: 'GET',
    headers: options?.headers,
    ...options
  };

  try {
    const response = await fetch(url, requestOptions);

    if (!response.ok) {
      callbacks.onError?.(new Error(`HTTP ${response.status}: ${response.statusText}`));
      return;
    }

    const reader = response.body?.getReader();
    const decoder = new TextDecoder();

    if (!reader) {
      callbacks.onError?.(new Error('Response body is not readable'));
      return;
    }

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const text = decoder.decode(value);
      callbacks.onChunk?.(text);
    }

    callbacks.onComplete?.();
  }
  catch (error) {
    callbacks.onError?.(error instanceof Error ? error : new Error('Text streaming error'));
  }
};